

Coding


```shell


import os
import numpy as np
import pandas as pd
import scipy.optimize as opt

class ChoiceModels(object):
   
    def load_data(self, path, file):
        df = pd.read_csv(os.path.join(path,file), sep='\s+', header=0)
        df['cons'] = 1.
        return df
    
    def expand_data(self, df, n):
        df['Alt'] = [[str(i) for i in range(n)] for _ in range(len(df))]
        return df.explode('Alt')
    
    def create_choice_attributes(self, df, config):
        # create dependent variable
        y_namelist = list(config['Alternatives']['0'].keys())
        df['choice'] = list(zip(*[df[v] for v in y_namelist]))
        df = self.expand_data(df, len(config['Alternatives']))
   
        df['y'] = 0.
        for k,v in config['Alternatives'].items():
            label = tuple(v.values())
            df.loc[(df["Alt"]==k) & (df['choice']==label), 'y'] = 1
        
        # create alternative specific attributes
        dic = config['Attributes']
        for var,info in dic.items():
            df[var] = 0
            for alt, w in info['rule'].items():
                df['junk'] = 0
                df.loc[(df['Alt'] == alt), 'junk'] = 1
                df[var] = df[var] + w * df[info['variable']] * df['junk'] 
        df = df.drop("junk", axis='columns')
        
        # creat interactions
        df, xz_list = self.create_interactions(df, config['Interactions']) 
        x_list = list(config['Attributes'].keys()) + xz_list
        return {'data': df, "var_names": x_list}
    
    def create_interactions(self, df, interact_list):
        xz_list = []
        for item in interact_list:
            vname = item[0] + "_" + item[1]
            df[vname] = df[item[0]] * df[item[1]]
            xz_list.append(vname)
        return df, xz_list 
        
        
    def optimization(self, objfun, para):
        v = opt.minimize(objfun, x0=para, jac=None, method='BFGS', 
                          options={'maxiter': 1000, 'disp': True})  
        return {'log_likelihood':-1*v.fun, "Coefficients": v.x, "Var_Cov": v.hess_inv}
```

```shell
class BinaryLogit(ChoiceModels):
    def __init__(self, path, file, yname, x=None, z=None, interactions=None):
        df = super().load_data(path, file)
        if x is None:
            x = []
        if z is None:
            z = []
        if interactions is None:
            xz = []
            self.df = df
        else:
            self.df, xz = super().create_interactions(df, interactions)
            
        self.X_list = ['cons'] + x + z + xz
        self.Xmat = self.df[self.X_list].to_numpy()
        self.y = self.df[yname].to_numpy()
        
    def log_likelihood(self, para):
        xb = np.matmul(self.Xmat, para)
        xb = np.exp(xb)
        xb = xb / (1+xb)
        return (-1/len(xb)) * np.sum(self.y * np.log(xb) + (1-self.y) * np.log(1 - xb))
   
    def estimation(self, para):
        return super().optimization(self.log_likelihood, para)


```


```shell
class MultinomialLogit(ChoiceModels):

    # Specify model here    
    model_config = {"Alternatives":
                    {"0": {"trans": 1, "occupanc": 1, "route": 1},
                     "1": {"trans": 1, "occupanc": 1, "route": 0},
                     "2": {"trans": 1, "occupanc": 2, "route": 1},
                     "3": {"trans": 1, "occupanc": 2, "route": 0},
                     "4": {"trans": 1, "occupanc": 3, "route": 1},
                     "5": {"trans": 1, "occupanc": 3, "route": 0},
                     "6": {"trans": 0, "occupanc": 1, "route": 0},
                     "7": {"trans": 0, "occupanc": 2, "route": 0},
                     "8": {"trans": 0, "occupanc": 3, "route": 0}},
                    "Nests": {"0":{"0": ["0", "1"], "1": ["2", "3"], 
                                   "2": ["4", "5"]},"1":["6", "7", "8"]},
                    "Attributes":{'trans_dummy':{'variable': 'cons', 
                                                 'rule':{"0":1,"1":1,
                                                         "2":1,"3":1,"4":1,"5":1}},
                                  'express_dummy':{'variable':'cons', 
                                                   'rule':{"0":1,"2":1,"4":1}},
                                  'hov2_dummy':{'variable':'cons', 
                                               'rule':{"2":1,"3":1,"7":1}},
                                  "hov3_dummy":{'variable':'cons', 
                                                'rule':{"4":1,"5":1,"8":1}},
                                  "price":{"variable": 'toll', 
                                           "rule": {"0":1,"2":1/2,"4":1/6}},
                                  "time": {"variable":"median", 
                                           "rule":{"0":1,"2":1,"4":1}}},
                    "Interactions":[('price', "high_income"), ('price', "med_income"),
                                    ("hov2_dummy", "householdsize"),
                                    ("hov3_dummy", "householdsize")],
                    "Mixedlogit":['price', 'time', 'trans_dummy', 'hov2_dummy', 'hov3_dummy']}
    
    
    def __init__(self, path, file):
        df = super().load_data(path, file)
        res = super().create_choice_attributes(df, MultinomialLogit.model_config)
        self.df = res['data']
        self.X_list = res['var_names']
        self.y = self.df['y'].to_numpy()
        self.Xmat = self.df[self.X_list].to_numpy()
               
    def mnl_log_likelihood(self, para):
        df = self.df.copy()
        xb = np.matmul(self.Xmat, para)
        xb = np.exp(xb)
        df['xb'] = xb.tolist()
        # group sum
        df['xbsum'] = df.groupby(['id'])["xb"].transform(lambda x: x.sum())
        df['log_likelihood'] = df['y']*np.log(df['xb'] / df['xbsum'])
        return (-1/len(df))* np.sum(df['log_likelihood'])
 
    def estimation(self, para):
        return super().optimization(self.mnl_log_likelihood, para)


```



```shell
    
class NestedLogit(ChoiceModels):  
    
    def __init__(self, path, file):
        df = super().load_data(path, file)
        res = super().create_choice_attributes(df, MultinomialLogit.model_config)
        self.df = res['data']
        self.X_list = res['var_names']
        self.y = self.df['y'].to_numpy()
        self.Xmat = self.df[self.X_list].to_numpy()
 
    def nl_log_likelihood(self,para):
        beta = para[0:k]
        lamda = para[k+1:k+2]
        delta = para[k+3:]
        df = self.df.copy()
        xb = np.matmul(self.Xmat, para)
        xb = np.exp(xb)
        df['xb'] = xb.tolist()
        df['IV_subnest'] = np.log(np.sum(np.exp((1/delta)*df['xb'])))
        df['IV_nest'] = np.log(np.sum(np.exp((delta/lamda)*df['IV_subnest'])))
        df['P_subnest'] = np.exp((1/delta)*df['xb'])/np.exp(df['IV_subnest'])
        df['P_nest'] = np.exp((delta/lamda)*df['IV_subnest'])/np.exp(df['IV_nest'])
        df['P_margin'] = np.exp(lamda*df['IV_nest'])/(np.sum(np.exp(lamda*df['IV_nest'])))
        df['log_likelihood'] = np.log(df['IV_nest']*df['P_subnest']*df['P_margin'])
        return (-1/len(df))*df['log_likelihood']
    
    def estimation(self, para):
        return super().optimization(self.nl_log_likelihood, para)


```
   

```shell


if __name__ == '__main__':
    p = r"/Users/jingjiexu/Desktop/514 Econometrics IV"
    f = "assignment 1.txt"
    
    ## p = r"c:\users\jiay\Econs514"
    ## f = "assignment 1.txt"
    ## estimating binary models
    x = ['toll', 'median']
    z = ['female', 'age3050', 'distance', 'householdsize']
    interactions = [('toll', 'high_income'), ('toll', 'med_income')]
    route = BinaryLogit(p, f, "route", x=x, z=z, interactions=interactions)
    bini = np.zeros(len(route.X_list))
    res_binary = route.estimation(bini)
    
    ## estimating a MNL model
    mnl = MultinomialLogit(p, f)
    bini = np.zeros(len(mnl.X_list))
    res_mnl = mnl.estimation(bini)
    
    ## estimating a NestedLogit model
    k = 6  ##6 observable attributes
    nl = NestedLogit(p,f)
    bini = np.zeros(len(nl.X_list))
    res_nl = nl.estimation(bini)
  
  ``` 

```



Binary: Optimization terminated successfully. Current function value: 0.528810 Iterations: 34 Function evaluations: 370 Gradient evaluations: 37  

Multinomial: Optimization terminated successfully. Current function value: 0.203781 Iterations: 67 Function evaluations: 748 Gradient evaluations: 68  

Nested:  

Preference Heterogeneity: Multinomial choice models can be used to investigate heterogeneity among commuters based on their joint occupancy/route choices. It is based on the idea that commuters have different preferences for travel time and money costs, and seeks to understand how these preferences influence the mode and route choice decisions. The model would involve the estimation of a set of parameters that describe the trade-off between travel time and money costs for each individual commuter, based on observed data on their mode and route choices. The parameters could then be used to segment the population of commuters into different groups, based on their preferences for these two factors. This information could be used to better understand and predict commuter behavior, and to design more effective policies and interventions aimed at improving the transportation system.
